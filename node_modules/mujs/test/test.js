const test = require("tape").test
const g8 = require("g8")
const Mu = require("../")
const mu = new Mu()

test("multiply two numbers", function (t) {
  mu.rom = [
    "0000000000", // a = @r0
    "1110000000", // m = 0
    "0000000110", // a = 6
    "1101000011", // x = a
    "0000000001", // a = @r1
    "1110000010", // m = x
    "0000000111", // a = 7
    "1101000011", // x = a
    "0000000010", // a = @r2
    "1110000010", // m = x      /*loop*/
    "0000000000", // a = @r0
    "1100000011", // x = m
    "0000000001", // a = @r1
    "1100001100", // x = x + m
    "0000000000", // a = @r0
    "1110000010", // m = x
    "0000000010", // a = @r2
    "1100001011", // x = m - 1
    "1110000010", // m = x
    "0000001010", // a = @loop
    "1000100010", // x > 0 jump
    "0000000000"  // a = @r0
  ]

  do {} while (mu.next(inspect))

  t.equal(mu.memory("0000000000"), "0000000000101010")
  t.end()
})

test("swap values of two memory addresses", function (t) {
  mu.rom = [
    "0111110100", // a = 500
    "1101000011", // x = a
    "0000000000", // a = @r0
    "1110000010", // m = x
    // r0 = 500
    "0110010000", // a = 400
    "1101000011", // x = a
    "0000000001", // a = @r1
    "1110000010", // m = x
    // r1 = 400
    "0000000000", // a = @r0
    "1100000011", // x = m
    "0000000010", // a = @r2
    "1110000010", // m = x
    // r2 = r0
    "0000000001", // a = @r1
    "1100000011", // x = m
    "0000000000", // a = @r0
    "1110000010", // m = x
    // r0 = r1
    "0000000010", // a = @r2
    "1100000011", // x = m
    "0000000001", // a = @r1
    "1110000010"  // m = x
    // r1 = r2
  ]
  do {} while (mu.next(inspect))
  t.equal(mu.memory("0000000000"), "0000000110010000")
  t.equal(mu.memory("0000000001"), "0000000111110100")
  t.end()
})

test("initialize an array with index + 1 + length", function (t) {
  mu.rom = [
    "0000001010", //    0:      a = 10
    "1101000011", //    1:      x = a
    "0000000000", //    2:      a = @n
    "1110000010", //    3:      m = x
    "0000000001", //    4:      a = @i
    "1110000000", //    5:      m = 0
    "0000000001", //  * 6:      a = @i    /*loop*/
    "1100000011", //    7:      x = m
    "0000000010", //    8:      a = @v*10
    "1101001100", //    9:      x = x + a
    "0000001100", ///  10:      a = @itptr
    "1110000010", //   11:      m = x
    "0000000000", //   12:      a = @n
    "1100000011", //   13:      x = m
    "0000000001", //   14:      a = @i
    "1010001001", //   15:      a = m + 1
    "1101001100", //   16:      x = x + a
    "0000001100", //   17:      a = @itptr
    "1010000011", //   18:      a = m
    "1110000010", //   19:      m = x
    "0000000001", //   20:      a = @i
    "1100001001", //   21:      x = m + 1
    "1110000010", //   22:      m = x
    "0000000000", //   23:      a = @n
    "1100001101", //   24:      x = x - m
    "0000000110", //   25:      a = @loop
    "1000010010"  //   26:   if x < 0 jump
  ]
  do {/*
    var n = 10, v = [10]
    for (var i = 0; i<n; i++)
      v[i] = i + 1 + n;
  */} while (mu.next(inspect))

  t.equal(mu.memory("0000000000"), "0000000000001010")
  t.equal(mu.memory("0000000001"), "0000000000001010")
  t.equal(mu.memory("0000000010"), "0000000000001011") // v[0]
  t.equal(mu.memory("0000000011"), "0000000000001100")
  t.equal(mu.memory("0000000100"), "0000000000001101")
  t.equal(mu.memory("0000000101"), "0000000000001110")
  t.equal(mu.memory("0000000110"), "0000000000001111")
  t.equal(mu.memory("0000000111"), "0000000000010000")
  t.equal(mu.memory("0000001000"), "0000000000010001")
  t.equal(mu.memory("0000001001"), "0000000000010010")
  t.equal(mu.memory("0000001010"), "0000000000010011")
  t.equal(mu.memory("0000001011"), "0000000000010100") // v[9]
  t.end()
})

test("select the largest of three numbers", function (t) {
  mu.rom = [
    "0111111000", // 0      a = 504
    "1101000011", // 1      x = a
    "0000000000", // 2      a = @n1
    "1110000010", // 3      m = x
    "0111111001", // 4      a = 505
    "1101000011", // 5      x = a
    "0000000001", // 6      a = @n2
    "1110000010", // 7      m = x
    "0111110110", // 8      a = 502
    "1101000011", // 9      x = a
    "0000000010", // 10     a = @n3
    "1110000010", // 11     m = x
    "0000000000", // 12     a = @n1
    "1100000011", // 13     x = m
    "0000000001", // 14     a = @n2
    "1100001101", // 15     x = x - m
    "0000011001", // 16     a  = @then
    "1000100010", // 17     jump if x > 0
    "1000110010", // 18     jump if x == 0
    "0000000001", // 19     a = @n2
    "1100000011", // 20     x = m
    "0000000011", // 21     a = @max
    "1110000010", // 22     m = x
    "0000011101", // 23     a = @endif
    "1100110000", // 24     jump
    "0000000000", //*25     a = @n1       // THEN
    "1100000011", // 26     x = m
    "0000000011", // 27     a = @max
    "1110000010", // 28     m = x
    "0000000011", //*29     a = @max      // ENDIF
    "1100000011", // 30     x = m
    "0000000010", // 31     a = @n3
    "1100001101", // 32     x = x - m
    "0000100101", // 33     a = @then2
    "1000010010", // 34     jump if x < 0
    "0000101001", // 35     a = @exit
    "1100110000", // 36     jump
    "0000000010", // 37     a = @n3       // THEN2
    "1100000011", // 38     x = m
    "0000000011", // 39     a = @max
    "1110000010", // 40     m = x
    "1000000000"  // 41     nothing       // EXIT
  ]

  do { } while (mu.next(inspect))

  t.equal(mu.memory("0000000011"), "0000000111111001")
  t.end()
})

function inspect (instruction, memory, a, x, cpu) {
  console.log("â†˜ RAM  " + parseInt(memory,2))
  console.log("    A  " + parseInt(a, 2))
  console.log("    X  " + parseInt(x, 2))
  console.log("   PC  " + parseInt(cpu.next, 2))
  console.log("-------------")
}
