const g8 = require('g8')
const Nu = module.exports = {}

/**
 * @type {Number} Word size.
 */
Nu.WORD = 16;
/**
 * Compute fn(x,y) according to fn:
 *
 *  0000 →  0     0001 →  1     0010 →  x     0011 →  y
 *  0100 → !x     0101 → !y     0110 → -x     0111 → -y
 *  1000 → x+1    1001 → y+1    1010 → x-1    1011 → y-1
 *  1100 → x+y    1101 → x-y    1110 → x&y    1111 → x|y
 *
 * @param {String} x N-bit binary number.
 * @param {String} y N-bit binary number.
 * @param {String} fn 4-bit binary number.
 * @return {String} obj.out N-length result.
 * @return {String} obj.zr 1-bit flag. 1 if out == 0
 * @return {String} obj.ng 1-bit flag. 1 if out < 0
 */
Nu.alu = function(x, y, fn) {
  var zero = g8.lo(x.length),
      one = g8.hi(x.length),
      nx = g8.not(x),
      ny = g8.not(y),
      out = g8.sel(
        zero, one, x, y, nx, ny,
        g8.add(nx, one), // -x
        g8.add(ny, one), // -y
        g8.add(x, one),  // x+1
        g8.add(y, one),  // y+1
        g8.add(x, g8.not(zero)), // x-1
        g8.add(y, g8.not(zero)), // y-1
        g8.add(x, y),               // x+y
        g8.add(g8.add(x, ny), one), // x-y
        g8.and(x, y),               // x&y
        g8.nand(nx, ny), fn)       // x|y
  return {
    zr: g8.not(g8.or(out)),
    ng: out[0],
    out: out,
  }
}
/**
 * Run 10-bit instructions and calculate next to fetch.
 * See README for a breakdown of the algorithm.
 *
 * @param {String} instruction (10-bit)
 * @param {String} memory Data from RAM.
 * @param {String} reset 1-bit flag to reset PC.
 * @param {Function} inspect Callback.
 * @return {String} obj.data ALUs output.
 * @return {String} obj.address 10-bit RAM address to write / read.
 * @return {String} obj.load 1-bit flag to load RAM.
 * @return {String} obj.next Next instruction to fetch from ROM.
 */
Nu.controller = function() {
  var A = g8.word(Nu.WORD),   // Accumulator register
      X = g8.word(Nu.WORD),   // Data register
      a = x = g8.lo(Nu.WORD), // A and X feedback outputs
      PC = g8.counter()      // Program counter and jump controller

  var cpu; return cpu = function(instruction, memory, reset, inspect) {
    // Decode the instruction into its meanigful bits.
    var i = g8.lo(6) + instruction,     //  Instruction bits as a word.
        comp = instruction[0],          //  00   01   10   11
        left = instruction.slice(1, 3), //  __    A    X    M
        y = instruction[3],             //   M    A
        jump = instruction.slice(4, 6), //  +1   <0   >0   =0
        right = instruction.slice(6)   //  See Nu.alu for opcodes.

    // Compute fn(X,Y) where X = last x and Y = memory or the A's last value.
    alu = Nu.alu(x, g8.sel(memory, a, y), right)

    // Save address or data to the accumulator if !LEFT:0 !& LEFT:1 !& comp.
    a = A(g8.sel(i, alu.out, comp),
      g8.nand(g8.nand(g8.not(left[0]), left[1]), comp))

    // Save data to X if comp && !LEFT:1 && LEFT:0
    x = X(alu.out, g8.and(comp, g8.and(g8.not(left[1]), left[0])))

    // Set CPU exports and calculate next instruction to fetch.
    cpu.out = alu.out;
    cpu.address = a.slice(Nu.WORD-10) // 10 bits of addressable memory
    cpu.load = g8.and(comp, g8.and(left[0], left[1]))

    // Evaluate ALU and JUMP bits to calculate next instruction.
    var load = g8.sel(
      g8.lo(),                // 00 ++
      alu.ng,                 // 01 OUT < 0
      g8.nor(alu.ng, alu.zr), // 11 OUT == 0
      alu.zr, jump)          // 10 OUT > 0
    cpu.next = PC(a, g8.and(comp, load), g8.nand(comp, load), reset)

    // Invoke inspect callback if available.
    if (inspect) inspect(instruction, memory, a, x, cpu)

    return cpu
  }
}
